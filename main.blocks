<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="AuU7n1ONcB/GaO$nZt3Z" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="YHDg[Jn6]Kei4y2#3=sA" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace XRbit_sensor {" line1="" line2="    export enum enVoice {" line3="        //% blockId=&quot;Voice&quot; block=&quot;Voice&quot;" line4="        Voice = 0," line5="        //% blockId=&quot;NoVoice&quot; block=&quot;NoVoice&quot;" line6="        NoVoice = 1" line7="    }" line8="" line9="    export enum enIR {" line10="        //% blockId=&quot;Get&quot; block=&quot;Get&quot;" line11="        Get = 0," line12="        //% blockId=&quot;NoVoice&quot; block=&quot;NoVoice&quot;" line13="        NoGet = 1" line14="    }" line15="" line16="    export enum enLight {" line17="        //% blockId=&quot;Open&quot; block=&quot;Open&quot;" line18="        Open = 0," line19="        //% blockId=&quot;Close&quot; block=&quot;Close&quot;" line20="        Close = 1" line21="    }" line22="" line23="    export enum enBuzzer {" line24="        //% blockId=&quot;NoBeep&quot; block=&quot;NoBeep&quot;" line25="        NoBeep = 0," line26="        //% blockId=&quot;Beep&quot; block=&quot;Beep&quot;" line27="        Beep" line28="    }" line29="    export enum irPin {" line30="        //% blockId=&quot;ir_Left&quot; block=&quot;Left_IR_P12&quot;" line31="        ir_Left = 1," line32="        //% blockId=&quot;ir_Right&quot; block=&quot;Right_IR_P14&quot;" line33="        ir_Right = 2," line34="        //% blockId=&quot;ir_Avoid&quot; block=&quot;Avoid_IR_P13&quot;" line35="        ir_Avoid = 3" line36="    }" line37="" line38="" line39="    //% blockId=XRbit_Buzzer block=&quot;Buzzer|pin %pin|value %value&quot;" line40="    //% weight=100" line41="    //% blockGap=10" line42="    //% color=&quot;#87CEEB&quot;" line43="    //% value.min=0 value.max=1" line44="    //% name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=4" line45="    export function Buzzer(pin: DigitalPin, value: enBuzzer): void {" line46="        pins.setPull(pin, PinPullMode.PullNone);" line47="        pins.digitalWritePin(pin, value);" line48="    }" line49="" line50="    //% blockId=XRbit_IR_Sensor block=&quot;IR_Sensor|pin %pin| |%value|obstacle&quot;" line51="    //% weight=100" line52="    //% blockGap=10" line53="    //% color=&quot;#87CEEB&quot;" line54="    //% name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=4" line55="    export function IR_Sensor(pin: irPin, value: enIR): boolean {" line56="        let Pin:DigitalPin;" line57="        if(pin==1)" line58="        {" line59="            Pin = DigitalPin.P12;" line60="        }" line61="        if(pin==2)" line62="        {" line63="            Pin = DigitalPin.P14;" line64="        }" line65="        if(pin==3)" line66="        {" line67="            Pin = DigitalPin.P13;" line68="        }" line69="" line70="        pins.setPull(Pin, PinPullMode.PullUp);" line71="        if (pins.digitalReadPin(Pin) == value) {" line72="            return true;" line73="        }" line74="        else {" line75="            return false;" line76="        }" line77="    }" line78="" line79="    //% blockId=XRbit_Car_Ligth block=&quot;Car_Ligth |pin %pin| |%value|Headlight&quot;" line80="    //% weight=100" line81="    //% blockGap=10" line82="    //% color=&quot;#87CEEB&quot;" line83="    //% name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=4" line84="    export function Car_Ligth(pin: DigitalPin, value: enLight): boolean {" line85="        pins.setPull(pin, PinPullMode.PullUp);" line86="        if (pins.digitalReadPin(pin) == value) {" line87="            return true;" line88="        }" line89="        else {" line90="            return false;" line91="        }" line92="    }" line93="" line94="    //% blockId=XRbit_ultrasonic block=&quot;Ultrasonic|Trig %Trig|Echo %Echo&quot;" line95="    //% color=&quot;#87CEEB&quot;" line96="    //% weight=100" line97="    //% blockGap=10" line98="    //% name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=4" line99="    export function Ultrasonic(Trig: DigitalPin, Echo: DigitalPin): number {" line100="        // send pulse" line101="        let list:Array&lt;number&gt; = [0, 0, 0, 0, 0];" line102="        for (let i = 0; i &lt; 5; i++) {" line103="            pins.setPull(Trig, PinPullMode.PullNone);" line104="            pins.digitalWritePin(Trig, 0);" line105="            control.waitMicros(2);" line106="            pins.digitalWritePin(Trig, 1);" line107="            control.waitMicros(15);" line108="            pins.digitalWritePin(Trig, 0);" line109="" line110="            let d = pins.pulseIn(Echo, PulseValue.High, 43200);" line111="            list[i] = Math.floor(d / 40)" line112="        }" line113="        list.sort();" line114="        let length = (list[1] + list[2] + list[3])/3;" line115="        return  Math.floor(length);" line116="    }" line117="}" numlines="118"></mutation><next><block type="typescript_statement" id="j#D3jcFNcTp*fS;[[rPe" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace XRbit_Trolley {" line1="    const XRBIT_ADDRESS = 0x17" line2="    let xrStrip: neopixel.Strip;" line3="    export enum enMotor {" line4="        //% blockId=&quot;leftMotor&quot; block=&quot;leftMotor&quot;" line5="        leftMotor = 0x14," line6="        //% blockId=&quot;rightMotor&quot; block=&quot;rightMotor&quot;" line7="        rightMotor = 0x15" line8="    }" line9="" line10="    export enum IRValue {" line11="        Power = 0x45," line12="        Menu = 0x47," line13="        Test = 0x44," line14="        Plus = 0x40," line15="        Return = 0x43," line16="        Left = 0x07," line17="        Play = 0x15," line18="        Right = 0x09," line19="        Num0 = 0x16," line20="        Minus = 0x19," line21="        Cancle = 0x0D," line22="        Num1 = 0x0C," line23="        Num2 = 0x18," line24="        Num3 = 0x5E," line25="        Num4 = 0x08," line26="        Num5 = 0x1C," line27="        Num6 = 0x5A," line28="        Num7 = 0x42," line29="        Num8 = 0x52," line30="        Num9 = 0x4A " line31="         " line32="    }" line33="" line34="    function i2cwrite(addr: number, reg: number, value: number): void {" line35="        let buf = pins.createBuffer(2);" line36="        buf[0] = reg;" line37="        buf[1] = value;" line38="        pins.i2cWriteBuffer(addr, buf);" line39="    }" line40="" line41="    function i2cread(addr: number, reg: number): number {" line42="        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);" line43="        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);" line44="        return val;" line45="    }" line46="    //% blockId=XRbit_SetMotor block=&quot;SetMotor|Motor %Motor|Speed %Speed&quot;" line47="    //% weight=94" line48="    //% blockGap=10" line49="    //% color=&quot;#0fbc11&quot;" line50="    //% Speed.min=-100 Speed.max=100" line51="    export function SetMotor(Motor: enMotor, Speed: number): void {" line52="        let buf1 = pins.createBuffer(2);" line53="        let buf2 = pins.createBuffer(2);" line54="        buf1[0] = 0xFF;" line55="        buf1[1] = Motor;" line56="        buf2[0] = Speed+100;" line57="        buf2[1] = 0xFF;" line58="        pins.i2cWriteBuffer(XRBIT_ADDRESS,buf1);" line59="        pins.i2cWriteBuffer(XRBIT_ADDRESS,buf2);" line60="    }" line61="" line62="    //% blockId=XRBIT_SetServoAngle block=&quot;SetServoAngle|Num %Num|Angle %Angle&quot;" line63="    //% weight=94" line64="    //% blockGap=10" line65="    //% color=&quot;#0fbc11&quot;" line66="    //% Num.min=1 Num.max=8 Angle.min=0 Angle.max=180" line67="    //% name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=9" line68="    export function SetServoAngle(Num: number, Angle: number): void {" line69="        let buf12 = pins.createBuffer(2);" line70="        let buf22 = pins.createBuffer(2);" line71="        buf12[0] = 0xFF;" line72="        buf12[1] = Num;" line73="        buf22[0] = Angle;" line74="        buf22[1] = 0xFF;" line75="        pins.i2cWriteBuffer(XRBIT_ADDRESS,buf12);" line76="        pins.i2cWriteBuffer(XRBIT_ADDRESS,buf22);" line77="    }" line78="" line79="    //% blockId=XRBIT_ReSetServoAngle block=&quot;ReSetServoAngle&quot;" line80="    //% weight=94" line81="    //% blockGap=10" line82="    //% color=&quot;#0fbc11&quot;" line83="    export function ReSetServoAngle(): void {" line84="        let buf13 = pins.createBuffer(2);" line85="        let buf23 = pins.createBuffer(2);" line86="        buf13[0] = 0xFF;" line87="        buf13[1] = 0x00;" line88="        buf23[0] = 0x01;" line89="        buf23[1] = 0xFF;" line90="        pins.i2cWriteBuffer(XRBIT_ADDRESS,buf13);" line91="        pins.i2cWriteBuffer(XRBIT_ADDRESS,buf23);" line92="    }" line93="    //% blockId=XRBIT_SaveServoAngle block=&quot;SaveServoAngle&quot;" line94="    //% weight=94" line95="    //% blockGap=10" line96="    //% color=&quot;#0fbc11&quot;" line97="    export function SaveServoAngle(): void {" line98="        let buf14 = pins.createBuffer(2);" line99="        let buf24 = pins.createBuffer(2);" line100="        buf14[0] = 0xFF;" line101="        buf14[1] = 0x11;" line102="        buf24[0] = 0x01;" line103="        buf24[1] = 0xFF;" line104="        pins.i2cWriteBuffer(XRBIT_ADDRESS,buf14);" line105="        pins.i2cWriteBuffer(XRBIT_ADDRESS,buf24);" line106="    }" line107="" line108="    //% blockId=XRit_RGB_Car_Program block=&quot;RGB_Car_Program&quot;" line109="    //% weight=99" line110="    //% blockGap=10" line111="    //% color=&quot;#0fbc11&quot;" line112="    //% name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=4" line113="    export function RGB_Car_Program(): neopixel.Strip {" line114="         " line115="        if (!xrStrip) {" line116="            xrStrip = neopixel.create(DigitalPin.P16, 4, NeoPixelMode.RGB);" line117="        }" line118="        return xrStrip;" line119="    }" line120="" line121="    //% blockId=irremote_on_pressed block = &quot;irremote_on_pressed on |%IRValue| button pressed&quot;" line122="    //% color=&quot;#0fbc11&quot;" line123="    //% name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=4" line124="    export function irremote_on_pressed(IRValue:IRValue): boolean {" line125="        let irread: boolean = false;" line126="        let IRreaddat = 0x00;" line127="        let reg = pins.createBuffer(1);" line128="        reg[0] = 0x16;" line129="        pins.i2cWriteBuffer(XRBIT_ADDRESS, reg);" line130="        IRreaddat = pins.i2cReadNumber(XRBIT_ADDRESS, NumberFormat.UInt8BE);" line131="        if (IRreaddat == IRValue) {" line132="            irread = true;" line133="        }" line134="        else { " line135="            irread = false;" line136="        }" line137="        return irread;" line138="    }" line139="}" numlines="140"></mutation></block></next></block></statement></block></xml>